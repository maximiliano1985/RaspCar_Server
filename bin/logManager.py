#!/usr/bin/python3
# This scripts appends to a unique log file the log files generated by the following scripts (services):
# - usb_share.py
# - obd_log.py (TBD)


import obd # not used but placed here to have the log_manager loaded after the obd_logger
import glob
import time
import os
import subprocess
import select
import getpass
import signal

SEM_RED   = False
SEM_GREEN = True

def keyboardInterruptHandler(signal, frame):
    print("KeyboardInterrupt (ID: {}) has been caught. Cleaning up...".format(signal))
    exit(0)

signal.signal(signal.SIGINT, keyboardInterruptHandler)

class logManager(Object):
    def __init__(self, file_logger_status = fileLogger()):
        print("##### LOG MANAGER INIT #####")
        self.file_logger_status = file_logger_status
        
        self.semaphore = SEM_GREEN
        self.monitored_file_procs = []
        self.monitored_file_pools = []
        
        self.nax_num_monitored_files = 10


    def process_log_file(self, f_proc):
        # if someone else is writing in the main log file, wait until the semaphore is released
        while self.semaphore == SEM_RED:
            sleep(0.1)
            
        if self.semaphore == SEM_GREEN:
            self.semaphore = SEM_RED
            log_line = f_proc.stdout.readline()
            self.file_logger_status.write_msg_to_log( log_line )
            self.semaphore = SEM_GREEN
            
            
    def register_log_to_monitor(self, log_name):
        num_monitored_files = len(self.monitored_file_procs)
        
        if num_monitored_files > self.nax_num_monitored_files:
            self.file_logger_status("Added file to monitor: "+log_name)
            
            f_proc = subprocess.Popen(['tail','-F', log_name],\
                stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            self.monitored_file_procs.append( f_proc )
                
            pool_obj = select.poll()
            pool_obj.register( self.monitored_file_procs[-1].stdout )
            self.monitored_file_pools.append( pool_obj )
            
        else:
            print("##### [WARNING] MAX NUMBER OF MONITORED FILES REACHED: " + str(num_monitored_files) + " #####")
            self.file_logger_status("Reached the max number of files to be monitor. Discarded: "+log_name)
        
        
    def run(self):
        time.sleep(10)
        num_files = len(self.monitored_file_procs)
        print("##### LOG MANAGER STARTED FOR "+str(num_files)+"#####")
        # get the newest file
        
        while True:
            time.sleep(0.1)
            for i in range( num_files ) :
                pool_obj = self.monitored_file_pools[i]
                f_proc   = self.monitored_file_procs[i]
                
                if pool_obj.poll(1):
                    self.process_log_file(f_proc)


if __name__ == '__main__':
    log_folder = "/home/pi/Documents/logs/"
    flogStatus = fileLogger(
        log_folder      = log_folder,
        log_filetoken   = ".log",
        log_sep         = " ",
        log_token       = "[L]")
    
    newestfile_usb = max(glob.iglob(log_folder+"usb_share/"+'2*.log'), key=os.path.getctime)
    newestfile_obd = max(glob.iglob(log_folder+"recorder_logs/" +'2*.log'), key=os.path.getctime)
    newestfile_pow = max(glob.iglob(log_folder+"powmngm_logs/" +'2*.log'), key=os.path.getctime)
    
    mngr = logManager( flogStatus )
    mngr.register_log_to_monitor( newestfile_usb )
    mngr.register_log_to_monitor( newestfile_obd )
    
    mngr.run()
